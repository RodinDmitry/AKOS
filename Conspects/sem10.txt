АКОС семинар
-------------------------------------------------------------------------------
Сети
_______________________________________________________________________________
Задание 
Чат на TCP
Жизнь на UDP
-------------------------------------------------------------------------------
gethostbyname
gethostbyaddr
-------------------------------------------------------------------------------
Разрешение имен
	/etc/hosts - список имен 
	DNS
	net-bios
Вопрос: приоритет источников разрешения имен
linux: nsswitch.cont - порядок использования
-------------------------------------------------------------------------------
TCP
Клиент
	socket(TCP) 
	sockaddr_in serv
	connect ( s , serv , ...)
	read(s)
	write(s)
	close(s)
	Порты 
	1-1023 служебные
	Клиенту порт и адрес оперционка присваивает автоматически
	при завершении процеса все соединения прерываются
	keep-alive пакеты - служебные пакеты
Сервер
	s = socket(TCP)
	bind(s,port) - привязка к определенному порту
	listen(s) - ожидание соединения
	while(1)
	{
		p = accept(s) - блоирующий вызов, ожидание клиента
		fork();(или pthread_create)  - параллельная обработка клиента
	}
    // s - занимается тройным рукопожатием
	// p - сокет для общения
-------------------------------------------------------------------------------
UDP
Клиент и сервер одинаковы
	s = socket(UDP)
	bind ( s , ml )
	sendto( s , toaddr ) 
	recvfrom ( s , fromaddr )
	send()
	recv()	
-------------------------------------------------------------------------------
Сигналы
-------------------------------------------------------------------------------
*Сигналы похожи на прерывания
*при передаче сигнала передается 1 байт информации
+ использования - возможность прервать процесс и передать управления
- использования - неизвестные структуры памяти
Что будет, если процесс получит два сигнала?
--Старые сигналы
kill(pid,sig);
signal(sig,func); - подмена обработчика однаразовая
При нажатии Ctrl-C отправляется SIG_ABRT
	func()
	{
		signal(sig,func);
		...
		...	
		...
	}
При отправке n сигналов процесс получит от 0 до n
Неперехватыемее сигналы
	SIG_KILL
	SIG_STOP
SIG_CONT можно перехватить
--Новые сигналы (POSIX)
sigaction(sig,sigaction_t)
sigwait() - подвешивает процесс в оидании сигнала
pthread_kill
Вопрос - какая нить будет обрабатывать kill?
SIGUSER1
SIGUSER2
-------------------------------------------------------------------------------
Добавить в чат корректный SIGABORT
						  SIGPIPE
-------------------------------------------------------------------------------
select	 - проверяет дескриптор(или диапазон) на возможность чтения, записи и ошибок
poll	 - аналогично
-------------------------------------------------------------------------------
Makefile
-------------------------------------------------------------------------------
a.out -> 1.o -> 1.c -> list.h
	  -> 2.o -> 2.c -> list.h
make
make -f file
-------------------------------------------------------------------------------
Makefile 
a.out : 1.o 2.o
		gcc 1.o 2.o
		...
		...
1.o  : 1.c list.h
		gcc 1.c 2.o
...
...
-------------------------------------------------------------------------------
make targetname - собрать только определенную цель
clean:
		rm *.o
PHONI  - виртуализация директивы
-------------------------------------------------------------------------------
СFLAGS = -c ...
вместо флагов $(CFLAGS)
make шаблоны
%.o : %.c
		gcc $(CFLAGS) $^


















































