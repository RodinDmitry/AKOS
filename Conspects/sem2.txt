АКОС семинар
программирование
unix позволяет писать на C почти без привлечения сторонних средств
printf не требует подключения stdio.h для работы(с предупреждениями)
этапы эволюции
1) машинные коды
2) assembler(1940е-1950е) и компиляторы(asm -> bin). на компилятор возлагается проверка корректности комманд.
упростилась проверка программ.
3) появление языков среднего и высокого уровня
   сокращение кол-ва команд( к примеру sqrt(b^2-4ac) занимает 10-20 комманд на ASM)
   появляется трансляция в ассемблер
   ( итоговый вид LANG -> ASM -> OBJ)
4) появление надстроек над языками (ООП,препроцессинг)
   CPP
   C preprocessor - утилита по поиску и замене текста
   комманды препроцессора начинаюся с # с новой строки
   * #define N 5
   Пример
   1)  int array[N];
   for(int i=0;i<2*N;++i)
   {
//
   }
   2)   классическая ошибка
    #define N 5+3
    int b = N // b = 8
    int a = 2*N; // a = 13, не 16
    (классическое решение данного случая - ())
   CPP простая утилита по замене текста
   3) #define min 3
      // ...
      y = min(a,b); // y = 3(a,b);
   *#include - "подставь содержимое этого файла вместо этой строчки"
   с точки зрения процессора переменных нет
   (типы операций: декларации и инструкции)
   *#if условие
Безописательный подход к переменным
x = 7
y = 5
z = x + y // при пропуске строки 2 получим корректную прогу c z = 7
В заголовочных файлах языка С хранятся декларации фунций, обеспечивающие контроль над прогой
В С++ нельзя вызывать без деклараций
Особенность стандартных библиотек - функции не реализуемые средствами языка
К примеру часть STL можно реализовать самим
К примеру вывод на экран библиотека С передает к системной библеотеке
Код преарящается в объектные файлы -> файлы библиотек(сборник объектных файлов)
1) Архивы об. файлов
ar(фрхиватор) принимает некоторое кол-во об. файлов и превращает их в архив
my.c -> my.o
linker принимет несколько об файлов и начинает их склеивать. Протокол склеивания находится в заголовке об файла, 
где указано какие функции есть в файле, а какие он запрашивает. 
После сшивания нужно установить точку входа(начало испольнения комманд)(main в C/C++)
exe(elf) файл исполняемый, в котором говорится, что при запуске надо сделать __start, который уже вызывает main
exe -> __start -> starter -> main
и первичная инициализация  
сс my.c // my.c->mu.obj->linker->my.elf
Динамически линкуемы библиотеки (dll , so(linux))
Идея: подключать библиотеки не при компиляции, а при запуске.
Link-on-Demand подключение по требованию, подключением занимается сама программа.
Задание
Изучить мануалы и ключи gcc,ld,ldd,nm 
Разобраться в этапах компиляции
собрать прогу с помощью ld








